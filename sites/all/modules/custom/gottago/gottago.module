<?php

define('GOTTAGO_FIELD_STATION', 'field_station');
define('GOTTAGO_FIELD_LINE', 'field_line');
define('GOTTAGO_FIELD_DELAY', 'field_delay');

/**
 * Implements hook_permission().
 */
function gottago_permission() {
  return array(
    'administer gottago api' => array(
      'title' => t('Administer GottaGo API'),
    ),
  );
}

/**
 * Implementation of hook_menu().
 */
function gottago_menu(){
  $items['gottago_status'] = array(
    'title' => 'GottaGo Status',
    'access callback' => TRUE,
    'page callback' => 'gottago_status',
    'type' => MENU_CALLBACK,
  );
  $items['gottago_status/%gottago/%'] = array(
    'title' => 'GottaGo Status',
    'access callback' => TRUE,
    'page callback' => 'gottago_status',
    'page arguments' => array(1, 2),
    'type' => MENU_CALLBACK,
  );
  $items['admin/config/system/gottago_api'] = array(
    'title' => 'GottaGo API',
    'description' => 'Configure the GottaGO API settings',
    'access arguments' => array('administer gottago api'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('gottago_admin'),
    'file' => 'gottago.admin.inc',
  );
  return $items;
}

/**
 * Magic placeholder for %gottago
 *
 * @param string $id
 *  The id of the gottago node, that is the title of the node.
 *
 * @return object
 *  The gottago node object, or FALSE if the node id was not found.
 */
function gottago_load($id) {
  $result = db_select('node', 'n')->fields('n', array('nid'))
          ->condition('n.type', 'gottago')->condition('n.title', $id)
          ->range(0, 1)->execute()->fetchField();
  // Do not return FALSE here because in this case the response will be 404 web
  // page, and we do not want that. The response must always a json formatted
  // string, and there we will put any other errors. So, if the node could not
  // be found, just return NULL.
  if ($result) {
    $node = node_load($result);
    if ($node) {
      return $node;
    }
  }
  return NULL;
}

/**
 * Returns the status of a gottago node.
 *
 * If the node is not specified, it tries to load the ids from $_GET.
 */
function gottago_status($gottago_node = NULL, $response = "json") {
  // If we have the gottago node, print the result only for it.
  $result = array();
  if (!is_null($gottago_node)) {
    $result = gottago_api('go_status', $gottago_node);
  }
  else {
    // Try to load the ids from $_GET.
    // @todo: improve this... now it makes a request for every id...
    if (isset($_GET['ids']) && count($_GET['ids'])) {
      foreach ($_GET['ids'] as $id) {
        $gottago_node = gottago_load($id);
        if ($gottago_node && !isset($result[$id])) {
          $result[$id] = gottago_api('go_status', $gottago_node);
        }
      }
    }
  }
  switch ($response) {
    case 'json':
    default:
      drupal_json_output($result);
      exit;

    case 'csv':
      print gottago_convert_csv($result);
      exit;
  }
  //
  //exit();
  //dpm($result);
  //return array('#markup' => 'test');
}

function gottago_convert_csv($result){
  $return = $result['status'] . ";";
  $return .= $result['status_changes']['go'] . ";";
  $return .= $result['status_changes']['no_go'] . ";";
  $return .= $result['status_changes']['off'] . ";";
  $return .= $result['next_refresh'] . ";";
  return $return;
}

/**
 * Entry point for the gottago API.
 *
 * @param string $type
 *  The type of the operation to call. Valid values so far:
 *   - go_status: used to return "yes" or "no", if the user will catch the next
 *     transport.
 */
function gottago_api($type, $gottago_node) {
  // @todo: it would be nice to use exceptions here...
  $return = array();
  if (!is_object($gottago_node)) {
    $return['error'] = 'not_configured';
    ob_start();
    echo '<pre>';
    print_r($gottago_node);
    $output = ob_get_clean();
    watchdog("gottago", "Calling the GottaGo API (" . $type .  ") with a wrong gottago_node object: " . $output, NULL, WATCHDOG_ERROR);
  }
  elseif (function_exists('gottago_api_' . $type)) {
    $return = call_user_func_array('gottago_api_' . $type, array($gottago_node));
  }
  else {
    $return['error'] = 'no_api';
    watchdog("gottago", "Calling the GottaGo API with a non-existing type: @type" , array('@type' => $type), WATCHDOG_ERROR);
  }
  return $return;
}

/**
 * Api function to get the status of the next departure.
 *
 * @return @todo document the return.
 */
function gottago_api_go_status($gottago_node) {
  // Prepare the data to query the API.
  $params['id'] = $gottago_node->{GOTTAGO_FIELD_STATION}[LANGUAGE_NONE][0]['value'];
  $query_result = gottago_api_query($params);
  $response = array();

  // Time to construct the json output out of the response.
  if ($query_result) {
    $next_departure = gottago_get_departure($gottago_node->{GOTTAGO_FIELD_STATION}[LANGUAGE_NONE][0]['value'],
                                                       $gottago_node->{GOTTAGO_FIELD_LINE}[LANGUAGE_NONE][0]['value'],
                                                       $query_result);
    // If there is no next departure, stop here, and just return the error.
    if (is_object($next_departure)) {
      $second_next_departure = gottago_get_departure($gottago_node->{GOTTAGO_FIELD_STATION}[LANGUAGE_NONE][0]['value'],
                                                         $gottago_node->{GOTTAGO_FIELD_LINE}[LANGUAGE_NONE][0]['value'],
                                                         $query_result, 1);
      // To go or not to go?
      $response['status'] = gottago_get_departure_status($next_departure, $gottago_node);
      // If the status is not go, it can happen that the status is go for the
      // second next departure, so check also that.
      if ($response['status'] !='go') {
        $second_next_status = gottago_get_departure_status($second_next_departure, $gottago_node);
        if ($second_next_status == 'go') {
          $response['status'] = 'go';
        }
      }
      // Status changes and the next refresh.
      $response['status_changes'] = gottago_get_next_statuses($next_departure, $second_next_departure, $gottago_node);
      $response['next_refresh'] = gottago_get_next_refresh($second_next_departure, $gottago_node, $next_departure);
    }
    else {
      $response = array('error' => 'no_data');
    }
  }
  else {
    $response = array('error' => 'no_api');
  }
  return $response;
}

/**
 * Queries the Transport API and returns the data.
 *
 * @param array $params
 *  An array of params that will be used in the query string.
 */
function gottago_api_query($params = array()) {
  $url_options = array(
    'external' => TRUE,
    'query' => $params,
  );
  $url = url(variable_get('gottago_stationboard_url', 'http://transport.opendata.ch/api.php/v1/stationboard'), $url_options);
  // @todo: Catch and handle any http errors.
  $return = drupal_http_request($url);
  if ($return->code == 200) {
    return json_decode($return->data);
  }
  watchdog("gottago", "Error while quering: " . $url . ". Error Code: ".$return->code . ". Error: ". $return->error, NULL);
  return FALSE;
}

/**
 * @todo: document it.
 */
function gottago_get_departure_status($departure, $gottago_node) {
  // The status is to go if the remaining time is between the number of
  // seconds that the user spends walking and the number of seconds that the
  // user spends walking + the On timeframe. So, if
  // - delay = the number of seconds the user uses for walking.
  // - go_timeframe = the number of seconds for the Go timeframe.
  // - no_go_timeframe = the numebr of seconds for the No Go timeframe.
  // - remaining_time = the remaining time
  // then the status is go if: delay < remaining_time <= delay + go_timeframe,
  // that means: 0 < remaining_time - delay <= go_timeframe.
  $delay = $gottago_node->{GOTTAGO_FIELD_DELAY}[LANGUAGE_NONE][0]['value'];
  $go_timeframe = variable_get('gottago_go_status_timeframe', 60);
  $no_go_timeframe = variable_get('gottago_no_go_status_timeframe', 30);
  if (0 < $departure->remaining_seconds - $delay && $departure->remaining_seconds - $delay <= $go_timeframe) {
    return 'go';
  }
  // The status is no_go if: remaining_time <= delay AND delay - remaining_time < no_go_timefreame.
  elseif ($departure->remaining_seconds <= $delay && $delay - $departure->remaining_seconds < $no_go_timeframe) {
    return 'no_go';
  }
  // In all other cases, the response is off.
  else {
    return 'off';
  }
}

/**
 * @todo: document it.
 * @param type $next_departure
 * @param type $second_next_departure
 * @param type $gottago_node
 */
function gottago_get_next_statuses($next_departure, $second_next_departure, $gottago_node) {
  // @todo: document why this is like that!
  $delay = $gottago_node->{GOTTAGO_FIELD_DELAY}[LANGUAGE_NONE][0]['value'];
  $go_timeframe = variable_get('gottago_go_status_timeframe', 60);
  $no_go_timeframe = variable_get('gottago_no_go_status_timeframe', 30);
  // If the next departure is FALSE or no_data, all the statuses are NULL.
  if (!$next_departure || is_string($next_departure)) {
    return array('go' => NULL, 'no_go' => NULL, 'off' => NULL);
  }
  // GO status.
  if ($next_departure->remaining_seconds - $delay - $go_timeframe > 0) {
    $statuses['go'] = $next_departure->remaining_seconds - $delay - $go_timeframe;
  }
  elseif (is_object($second_next_departure)) {
    $statuses['go'] = $second_next_departure->remaining_seconds - $delay - $go_timeframe;
  }
  else {
    $statuses['go'] = NULL;
  }
  // NO GO status.
  if ($next_departure->remaining_seconds - $delay > 0) {
    $statuses['no_go'] = $next_departure->remaining_seconds - $delay;
  }
  elseif (is_object($second_next_departure)) {
    $statuses['no_go'] = $second_next_departure->remaining_seconds - $delay;
  }
  else {
    $statuses['no_go'] = NULL;
  }
  // OFF status.
  if ($next_departure->remaining_seconds - $delay + $no_go_timeframe > 0) {
    $statuses['off'] = $next_departure->remaining_seconds - $delay + $no_go_timeframe;
  }
  elseif (is_object($second_next_departure)) {
    $statuses['off'] = $second_next_departure->remaining_seconds - $delay + $no_go_timeframe;
  }
  else {
    $statuses['off'] = NULL;
  }
  return $statuses;
}



/**
 * Implements hook_form_alter().
 */
function gottago_form_gottago_node_form_alter(&$form, &$form_state, $form_id) {
  $form['field_station']['und'][0]['value']['#ajax'] = array(
    'callback' => 'gottago_ajax_callback_field_station_select',
    'wrapper' => 'gottago-line',
    'event' => 'change',
  );

  $form['field_station']['#suffix'] = '<div id="gottago-line" class="gottago-line"></div>';
  if (isset($form_state['values']['field_station']['und'][0]['value'])) {
    $stationid = $form_state['values']['field_station']['und'][0]['value'];
    $radio_options = gottago_get_lines_for_station($stationid);
  }
  if (isset($radio_options)) {
    $form['field_line']['und']['#options'] = $radio_options;
    $form['field_line']['#access'] = TRUE;
    $form['field_line']['#prefix'] = '<div id="gottago-line" class="gottago-line">';
    $form['field_line']['#suffix'] = '</div>';
  } else {
    $form['field_line']['#access'] = FALSE;
  }
}

/**
 * Ajax callback for loading the translator plugin settings form for the
 * currently selected translator plugin.
 */
function gottago_ajax_callback_field_station_select($form, &$form_state) {
  return $form['field_line'];
}

/**
 * Queries the TransportAPI for the given StationID and returns all Lines which
 * are running in the near future
 *
 * @param $stationid
 *    The stationid how TransportAPI would need it
 *
 * @return $lines
 *    An array of all liney in the near future.
 *    Key: linename|destination (lineidentifier)
 */
function gottago_get_lines_for_station($stationid = FALSE){

  if (!isset($stationid) || !is_numeric($stationid)){
    return FALSE;
  }
  $response = gottago_api_query(array('id' => $stationid));
  $lines = array();

  /**
   * There is no really possibility to get all lines for a station.
   * So we just go through all departs and get the possible lines from it.
   */
  foreach ($response->stationboard as $key => $departure) {
    $line_identifier = $departure->name . "|" . $departure->to;
    if (!in_array($line_identifier, $lines)) {
      $lines[$line_identifier] = t('@departure_name direction @departure_to', array('@departure_name' => $departure->name, '@departure_to' => $departure->to));
    }
  }
  return $lines;
}

/**
 * @todo: document it.
 */
function gottago_get_next_refresh($second_next_departure, $gottago_node, $next_departure) {
  if (!is_object($second_next_departure)) {
    return 0;
  }
  $delay = $gottago_node->{GOTTAGO_FIELD_DELAY}[LANGUAGE_NONE][0]['value'];
  $go_timeframe = variable_get('gottago_go_status_timeframe', 60);
  $next_refresh_timeframe = variable_get('gottago_refresh_timeframe', 60);
  return max($second_next_departure->remaining_seconds - $delay - $go_timeframe - $next_refresh_timeframe, 0);
}

/**
 * Queries the LocationAPI for the next departure of a line
 * @param type $stationid
 *    The stationid how TransportAPI would need it
 * @param type $line_identifier
 *    The Line Identifier as sent by gottago_get_lines_for_station()
 * @param type $skip_results
 *    How many results of the request should be skipped
 *
 * @return object $remaining_object
 *   The transportation object as it is defined in the api_response, but it will
 *   contain additionally also the number of remaining seconds.
 */
function gottago_get_departure($stationid, $line_identifier, $api_response = NULL, $offset = 0){
  // If we have no $api_response, generate one now.
  if (!$api_response) {
    $params['id'] = $stationid;
    $api_response = gottago_api_query($params);
  }
  if ($api_response) {
    // We use internally a pipe delimited line identifier, the API gives us this
    // different.
    $line_identifier = explode("|", $line_identifier);
    $line_name = $line_identifier[0];
    $line_to = $line_identifier[1];
    $departure_time = FALSE;
    $departure_object = NULL;

    foreach ($api_response->stationboard as $key => $departure) {
      // Is the found depart for the line we are searching for?
      if ($line_name == $departure->name && $line_to == $departure->to) {
        // Maybe we have to skip this result.
        if ($offset == 0) {
          $departure_time = (isset($departure->stop->prognosis->time)) ? $departure->stop->prognosis->time : $departure->stop->departure;
          $departure_object = $departure;
          break;
        } else {
          $offset--;
        }
      }
    }
    if (!$departure_time) {
      return "no_data";
    }
    // @todo: Maybe make some additional checks regarding the timezone if
    // needed...
    $departure_time = strtotime($departure_time);
    $current_time = time();
    // If the departure time is smaller then the current time, the departure
    // time is probably in the future so we add a day. But, add also a delta,
    // because the request can be performed in the same minute as the
    // departure time, and this will result in adding a day when it is not
    // necessary.
    if ($departure_time + 120 < $current_time) {
      $departure_time = $departure_time + (24 * 60 * 60);
    }
    $remaining_seconds = $departure_time - $current_time;
    $departure_object->remaining_seconds = $remaining_seconds;
    return $departure_object;
  }
  return FALSE;
}
