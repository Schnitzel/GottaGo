<?php

/**
 * Implementation of hook_menu().
 */
function gottago_menu(){
  $items['test'] = array(
      'title' => 'Test',
      'description' => 'Management of general issue settings',
      'access arguments' => array('access content'),
      'page callback' => 'gottago_test',
  );
  return $items;
}

function gottago_test(){
  $return = gottago_get_departure_in_seconds('008580522', 'Tram 4|ZÃ¼rich Altstetten, Bahnhof N');
  dpm($return);
  return "";
}

/**
 * Queries the TransportAPI for the given StationID and returns all Lines which
 * are running in the near future
 *
 * @param $stationid
 *    The stationid how TransportAPI would need it
 *
 * @return $lines
 *    An array of all liney in the near future.
 *    Key: linename|destination (lineidentifier)
 */
function gottago_get_lines_for_station($stationid){

  if (!isset($stationid) || !is_numeric($stationid)){
    return FALSE;
  }

  $return = drupal_http_request("http://transport.opendata.ch/api.php/v1/stationboard?id=".$stationid);
  if ($return->code == 200) {
    $response = json_decode($return->data);
  } else {
    watchdog("gottago", "Error while quering: http://transport.opendata.ch/api.php/v1/stationboard?id=" . $stationid . "
      Error Code: ".$return->code . ". Error: ". $return->error);
    return "no_api";
  }

  $lines = array();

  /**
   * There is no really possibility to get all lines for a station.
   * So we just go through all departs and get the possible lines from it.
   */
  foreach ($response->stationboard as $key => $departure) {
    $line_identifier = $departure->name . "|" . $departure->to;
    if (!in_array($line_identifier, $lines)) {
      $lines[$line_identifier] = $departure->name . " " . t('direction:') . " " . $departure->to;
    }
  }
  return $lines;
}

/**
 * Queries the LocationAPI for the next departure of a line
 * @param type $stationid
 *    The stationid how TransportAPI would need it
 * @param type $line_identifier
 *    The Line Identifier as sent by gottago_get_lines_for_station()
 * @param type $skip_results
 *    How many results of the request should be skipped
 *
 * @return $remaining_seconds
 *    Remaining seconds of the next departure
 */
function gottago_get_departure_in_seconds($stationid, $line_identifier, $skip_results = 0){
  $return = drupal_http_request("http://transport.opendata.ch/api.php/v1/stationboard?id=".$stationid);
  if ($return->code == 200) {
    $response = json_decode($return->data);
  } else {
    watchdog("gottago", "Error while quering: http://transport.opendata.ch/api.php/v1/stationboard?id=" . $stationid . "
      Error Code: ".$return->code . ". Error: ". $return->error);
    return "no_api";
  }

  // we use internally a pipe delimited line identifier, the API gives us this different.
  $line_identifier = explode("|", $line_identifier);
  $line_name = $line_identifier[0];
  $line_to = $line_identifier[1];
  $departure_time = FALSE;

  foreach ($response->stationboard as $key => $departure) {
    // is the found depart for the line we are searching for?
    if ($line_name == $departure->name && $line_to == $departure->to) {
      // maybe we have to skip this result.
      if ($skip_results == 0) {
        $departure_time = (isset($departure->stop->prognosis->time)) ? $departure->stop->prognosis->time : $departure->stop->departure;
        break;
      } else {
        $skip_results--;
      }
    }
  }
  if (!$departure_time) {
    return "no_data";
  }
  $departure_time = strtotime($departure_time);
  $current_time = time();
  // if the departure time is smaller then the current time, the departure time is probably in the future
  // so we add a day
  if ($departure_time < $current_time) {
    $departure_time = $departure_time + (24 * 60 * 60);
  }
  $remaining_seconds = $departure_time - $current_time;
  return $remaining_seconds;
}
