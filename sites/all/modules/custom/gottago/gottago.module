<?php

define('GOTTAGO_FIELD_STATION', 'field_station');

/**
 * Implements hook_permission().
 */
function gottago_permission() {
  return array(
    'administer gottago api' => array(
      'title' => t('Administer GottaGo API'),
    ),
  );
}

/**
 * Implementation of hook_menu().
 */
function gottago_menu(){
  $items['test'] = array(
      'title' => 'Test',
      'description' => 'Management of general issue settings',
      'access arguments' => array('access content'),
      'page callback' => 'gottago_test',
  );
  $items['gottago_status/%gottago'] = array(
    'title' => 'GottaGo Status',
    'access callback' => TRUE,
    'page callback' => 'gottago_api',
    'page arguments' => array('go_status', 1),
    'type' => MENU_CALLBACK,
  );
  $items['admin/config/system/gottago_api'] = array(
    'title' => 'GottaGo API',
    'description' => 'Configure the GottaGO API settings',
    'access arguments' => array('administer gottago api'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('gottago_admin'),
    'file' => 'gottago.admin.inc',
  );
  return $items;
}

/**
 * Magic placeholder for %gottago
 * 
 * @param string $id
 *  The id of the gottago node, that is the title of the node.
 * 
 * @return object
 *  The gottago node object, or FALSE if the node id was not found.
 */
function gottago_load($id) {
  $result = db_select('node', 'n')->fields('n', array('nid'))
          ->condition('n.type', 'gottago')->condition('n.title', $id)
          ->range(0, 1)->execute()->fetchField();
  // Do not return FALSE here because in this case the response will be 404 web
  // page, and we do not want that. The response must always a json formatted
  // string, and there we will put any other errors. So, if the node could not
  // be found, just return NULL.
  if ($result) {
    $node = node_load($result);
    if ($node) {
      return $node;
    }
  }
  return NULL;
}

/**
 * Entry point for the gottago API.
 * 
 * @param string $type
 *  The type of the operation to call. Valid values so far:
 *   - go_status: used to return "yes" or "no", if the user will catch the next
 *     transport.
 */
function gottago_api($type, $gottago_node) {
  // @todo: handle errors here, like checking the gottago node to be valid,
  // because this is not done in the magic placeholder function.
  $result = array();
  if (function_exists('gottago_api_' . $type)) {
    $return = call_user_func_array('gottago_api_' . $type, array($gottago_node));
  }
  //drupal_json_output($return);
  //exit();
  return array('#markup' => 'test');
}

/**
 * Api function to get the status of the next way of transport.
 * 
 * @return @todo document the return.
 */
function gottago_api_go_status($gottago_node) {
  // Prepare the data to query the API.
  $params['id'] = $gottago_node->{GOTTAGO_FIELD_STATION}[LANGUAGE_NONE][0]['value'];
  $query_result = gottago_api_query($params);
  $response = array();

  // Time to construct the json output out of the response.
  if ($query_result) {
    dpm($query_result);
    dpm($gottago_node);
    // To go or not to go?
    $response['status'] = 'no_go';
    // Status changes.
    $response['status_changes']['off'] = '210';
    $response['status_changes']['go'] = '120';
    $response['status_changes']['no_go'] = '180';
    // Next refresh
    $response['next_refresh'] = '23345';
  }
  // @todo: handle the errors.
  return $response;
}

/**
 * Queries the Transport API and returns the data.
 * 
 * @param array $params
 *  An array of params that will be used in the query string.
 */
function gottago_api_query($params = array()) {
  $url_options = array(
    'external' => TRUE,
    'query' => $params,
  );
  $url = url(variable_get('gottago_stationboard_url', 'http://transport.opendata.ch/api.php/v1/stationboard'), $url_options);
  dpm($url);
  // @todo: Catch and handle any http errors.
  $return = drupal_http_request($url);
  if ($return->code == 200) {
    return json_decode($return->data);
  }
  return FALSE;
}

function gottago_test(){
  $return = gottago_get_next_departure_in_seconds('008580522', 'Tram 4|ZÃ¼rich Altstetten, Bahnhof N');
  dpm($return);
  return "";
}

function gottago_get_lines_for_station($stationid){

  if (!isset($stationid) || !is_numeric($stationid)){
    return FALSE;
  }

  $return = drupal_http_request("http://transport.opendata.ch/api.php/v1/stationboard?id=".$stationid);
  if ($return->code == 200) {
    $response = json_decode($return->data);
  } else {
    return FALSE;
  }

dpm($response);
  $lines = array();
  foreach ($response->stationboard as $key => $departure) {
    $line_identifier = $departure->name . "|" . $departure->to;
    if (!in_array($line_identifier, $lines)) {
      $lines[$line_identifier] = $departure->name . " " . t('direction:') . " " . $departure->to;
    }
  }
  return $lines;
}

function gottago_get_next_departure_in_seconds($stationid, $line_identifier){
  $return = drupal_http_request("http://transport.opendata.ch/api.php/v1/stationboard?id=".$stationid);
  if ($return->code == 200) {
    $response = json_decode($return->data);
  } else {
    return FALSE;
  }
  $line_identifier = explode("|", $line_identifier);
  $line_name = $line_identifier[0];
  $line_to = $line_identifier[1];
  $departure_time = FALSE;
  foreach ($response->stationboard as $key => $departure) {
    if ($line_name == $departure->name && $line_to == $departure->to) {
      $departure_time = (isset($departure->stop->prognosis->time)) ? $departure->stop->prognosis->time : $departure->stop->departure;
      break;
    }
  }
  $departure_time = strtotime($departure_time);
  $current_time = time();
  // if the departure time is smaller then the current time, the departure time is probably in the future
  // so we add a day
  if ($departure_time < $current_time) {
    $departure_time = $departure_time + (24 * 60 * 60);
  }
  $remaining_seconds = $departure_time - $current_time;
  return $remaining_seconds;
}
