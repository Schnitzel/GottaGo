<?php

/**
 * Implementation of hook_menu().
 */
function gottago_menu(){
  $items['test'] = array(
      'title' => 'Test',
      'description' => 'Management of general issue settings',
      'access arguments' => array('access content'),
      'page callback' => 'gottago_test',
  );
  return $items;
}

function gottago_test(){
  $return = gottago_get_departure_in_seconds('008580522', 'Tram 4|ZÃ¼rich Altstetten, Bahnhof N');
  dpm($return);
  return "";
}


/**
 * Add output to the head tag of the HTML page.
 *
 * This function can be called as long the headers aren't sent. Pass no
 * arguments (or NULL for both) to retrieve the currently stored elements.
 *
 * @param $data
 *   A renderable array. If the '#type' key is not set then 'html_tag' will be
 *   added as the default '#type'.
 * @param $key
 *   A unique string key to allow implementations of hook_html_head_alter() to
 *   identify the element in $data. Required if $data is not NULL.
 *
 * @return
 *   An array of all stored HEAD elements.
 *
 * @see theme_html_tag()
 */

/**
 * Queries the TransportAPI for the given StationID and returns all Lines which
 * are running in the near future
 *
 * @param $stationid
 *    The stationid how TransportAPI would need it
 *
 * @return $lines
 *    An array of all liney in the near future.
 *    Key: linename|destination (lineidentifier)
 */
function gottago_get_lines_for_station($stationid){

  if (!isset($stationid) || !is_numeric($stationid)){
    return FALSE;
  }

  $return = drupal_http_request("http://transport.opendata.ch/api.php/v1/stationboard?id=".$stationid);
  if ($return->code == 200) {
    $response = json_decode($return->data);
  } else {
    return FALSE;
  }


  $lines = array();
  foreach ($response->stationboard as $key => $departure) {
    $line_identifier = $departure->name . "|" . $departure->to;
    if (!in_array($line_identifier, $lines)) {
      $lines[$line_identifier] = $departure->name . " " . t('direction:') . " " . $departure->to;
    }
  }
  return $lines;
}

/**
 * Queries the LocationAPI for the next departure of a line
 * @param type $stationid
 *    The stationid how TransportAPI would need it
 * @param type $line_identifier
 *    The Line Identifier as sent by gottago_get_lines_for_station()
 * @param type $skip_results
 *    How many results of the request should be skipped
 *
 * @return $remaining_seconds
 *    Remaining seconds of the next departure
 */
function gottago_get_departure_in_seconds($stationid, $line_identifier, $skip_results = 0){
  $return = drupal_http_request("http://transport.opendata.ch/api.php/v1/stationboard?id=".$stationid);
  if ($return->code == 200) {
    $response = json_decode($return->data);
  } else {
    return FALSE;
  }
  $line_identifier = explode("|", $line_identifier);
  $line_name = $line_identifier[0];
  $line_to = $line_identifier[1];
  $departure_time = FALSE;
  foreach ($response->stationboard as $key => $departure) {
    if ($line_name == $departure->name && $line_to == $departure->to) {
      if ($skip_results == 0) {
        $departure_time = (isset($departure->stop->prognosis->time)) ? $departure->stop->prognosis->time : $departure->stop->departure;
        break;
      } else {
        $skip_results--;
      }
    }
  }
  $departure_time = strtotime($departure_time);
  $current_time = time();
  // if the departure time is smaller then the current time, the departure time is probably in the future
  // so we add a day
  if ($departure_time < $current_time) {
    $departure_time = $departure_time + (24 * 60 * 60);
  }
  $remaining_seconds = $departure_time - $current_time;
  return $remaining_seconds;
}
